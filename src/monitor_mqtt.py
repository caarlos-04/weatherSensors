#!/usr/bin/env python3

import paho.mqtt.client as mqtt
import json
import logging
import time
import sys
import argparse
import threading
from datetime import datetime
from collections import defaultdict
from topics import (DATA_ALL, STATUS_ALL, CTRL_SEND_ALL, CONTROL_ALL, CONFIG_ALL, 
                    ALERT_ALL, BELIEF_ALL, FEEDBACK_ALL, feedback_topic, 
                    reject_topic, assign_sector_topic)

logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - [MONITOR] - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)


class WeatherMonitor:
    """
    DAI Monitor/Observer - Supervision and Logging System
    
    Role in DAI: Observer and coordinator, NOT central controller.
    - Receives and logs telemetry data
    - Observes beliefs and decisions from autonomous sensors
    - Tracks alerts generated by distributed consensus
    - Provides feedback for learning (optional)
    - Visualizes emergent behavior of the system
    """
    
    def __init__(self, broker: str = "localhost", port: int = 1883, 
                 stats_interval: int = 30, verbose: bool = False):
        """
        Initialize the monitor.
        
        Args:
            broker: MQTT broker address
            port: MQTT broker port
            stats_interval: Interval in seconds to display statistics
            verbose: Enable verbose logging
        """
        self.broker = broker
        self.port = port
        self.max_sensors = 6  # FIXED: always 6 sensors maximum
        self.stats_interval = stats_interval
        self.verbose = verbose
        self.client = mqtt.Client(client_id="weather_monitor")
        
        # Configure callbacks
        self.client.on_connect = self.on_connect
        self.client.on_message = self.on_message
        self.client.on_subscribe = self.on_subscribe
        
        # Available sectors (monitor auto-assigns them)
        self.available_sectors = ["sector1", "sector2", "sector3", "sector4", "sector5", "sector6"]
        self.assigned_sectors = {}  # {sector: sensor_id}
        
        # Store sensor data (telemetry)
        self.sensor_data = defaultdict(dict)  # {sensor_id: {latest_measurements}}
        self.sensor_status = {}  # {sensor_id: "online"/"offline"}
        self.sensor_sectors = {}  # {sensor_id: sector}
        self.connected_sensors = set()  # Set of currently connected sensor IDs
        
        # Store beliefs (DAI - distributed opinions)
        self.sensor_beliefs = defaultdict(dict)  # {sensor_id: {belief_data}}
        
        # Store alerts (generated by sensors, not by monitor)
        self.alerts = []  # List of all alerts received
        
        # Statistics
        self.message_count = {"data": 0, "belief": 0, "alert": 0, "status": 0}
        self.start_time = time.time()
        self.last_stats_time = time.time()
        
        # Control flags
        self.running = False

        logger.info("="*80)
        logger.info("DAI Monitor initialized (Observer/Supervisor + Manager)")
        logger.info(f"   Max sensors: {self.max_sensors} (FIXED)")
        logger.info(f"   Stats display interval: {self.stats_interval}s")
        logger.info("   Monitor will auto-assign sectors to connecting sensors")
        logger.info("   Commands: 'status' or 'quit'")
        logger.info("="*80)

    def on_connect(self, client, userdata, flags, rc):
        """Callback to handle connection to the broker"""
        if rc == 0:
            logger.info("Monitor connected to broker")

            # Subscribe to all relevant topics (observer mode)
            self.client.subscribe(DATA_ALL, qos=1)
            self.client.subscribe(STATUS_ALL, qos=1)
            self.client.subscribe(ALERT_ALL, qos=1)
            self.client.subscribe(BELIEF_ALL, qos=1)  # DAI: observe beliefs
            
            logger.info("Subscribed to: data, status, alerts, and beliefs")
            logger.info("Monitor is observing autonomous sensor behavior...")

            
        else:
            logger.error(f"Error, code {rc}")
    
    def on_subscribe(self, client, userdata, mid, granted_qos):
        """Callback when subscribing to a topic"""
        logger.info(f"Subscription successful with QoS: {granted_qos}")

    def on_message(self, client, userdata, msg):
        """Callback when receiving a message (observer pattern)"""
        topic = msg.topic
        try:
            # Parse the topic to determine the message type
            parts = topic.split('/')
            
            if parts[0] != "weather":
                return
            
            msg_type = parts[1]  # data, status, alert, belief, etc.
            
            # Process message based on its type (observe, don't control)
            if msg_type == "data":
                self.handle_data(topic, msg.payload)
            elif msg_type == "status":
                self.handle_status(topic, msg.payload)
            elif msg_type == "alert":
                self.handle_alert(topic, msg.payload)
            elif msg_type == "belief":  # DAI: observe distributed opinions
                self.handle_belief(topic, msg.payload)
            else:
                logger.debug(f"Unhandled message type: {msg_type}")
                
        except Exception as e:
            logger.error(f"Error processing message: {e}")

    def handle_data(self, topic: str, payload: bytes):
        """
        Observe telemetry data from sensors (passive observation).
        
        Args:
            topic: MQTT Topic (e.g., weather/data/pyrenees/meteo/meteo-001)
            payload: JSON payload with measurements
        """
        try:
            data = json.loads(payload.decode('utf-8'))
            sensor_id = data.get("sensor_id")
            
            # Store latest data
            self.sensor_data[sensor_id] = {
                "temperature": data.get("temperature_c"),
                "humidity": data.get("humidity_pct"),
                "pressure": data.get("pressure_hpa"),
                "altitude": data.get("altitude_m"),
                "timestamp": data.get("timestamp"),
                "last_seen": datetime.now().isoformat()
            }
            
            self.message_count["data"] += 1
            
            logger.info(f"DATA [{sensor_id}]: T:{data.get('temperature_c'):.1f}Â°C "
                       f"P:{data.get('pressure_hpa'):.1f}hPa H:{data.get('humidity_pct'):.0f}%")
        
        except Exception as e:
            logger.error(f"Error handling data: {e}")

    def handle_status(self, topic: str, payload: bytes):
        """
        Process status changes of sensors (online/offline).
        Manage sensor connections, enforce max limit, and auto-assign sectors.
        
        Args:
            topic: Topic MQTT (ej: weather/status/pyrenees/meteo/meteo-001)
            payload: JSON with sensor_id, status, timestamp
        """
        try:
            data = json.loads(payload.decode('utf-8'))
            sensor_id = data.get("sensor_id")
            status = data.get("status", "unknown")
            
            old_status = self.sensor_status.get(sensor_id, "unknown")
            
            if status == "online" and old_status != "online":
                # Sensor attempting to connect
                if len(self.connected_sensors) >= self.max_sensors:
                    # REJECT: Limit reached
                    logger.warning(f"REJECTED: {sensor_id} - Maximum {self.max_sensors} sensors reached!")
                    logger.warning(f"   Current sensors: {', '.join(sorted(self.connected_sensors))}")
                    self._reject_sensor(sensor_id)
                    return
                
                # AUTO-ASSIGN SECTOR
                assigned_sector = self._assign_sector(sensor_id)
                if assigned_sector is None:
                    logger.error(f"ERROR: No sectors available for {sensor_id}")
                    self._reject_sensor(sensor_id, reason="No sectors available")
                    return
                
                # Accept connection
                self.connected_sensors.add(sensor_id)
                self.sensor_status[sensor_id] = status
                self.sensor_sectors[sensor_id] = assigned_sector
                logger.info(f"CONNECTED: {sensor_id} [{assigned_sector}] - Total: {len(self.connected_sensors)}/{self.max_sensors}")
                
                # Send sector assignment to sensor
                self._send_sector_assignment(sensor_id, assigned_sector)
                
            elif status == "offline" and old_status == "online":
                # Sensor desconectando - liberar sector
                if sensor_id in self.connected_sensors:
                    self.connected_sensors.remove(sensor_id)
                
                sector = self.sensor_sectors.get(sensor_id)
                if sector and sector in self.assigned_sectors:
                    del self.assigned_sectors[sector]
                    logger.info(f"ðŸ”“ Sector {sector} is now available")
                
                self.sensor_status[sensor_id] = status
                logger.info(f"DISCONNECTED: {sensor_id} [{sector}] - Total: {len(self.connected_sensors)}/{self.max_sensors}")
            
            self.message_count["status"] += 1
            
        except json.JSONDecodeError:
            # Fallback for old format (plain text)
            sensor_id = topic.split('/')[-1]
            status = payload.decode()
            old_status = self.sensor_status.get(sensor_id, "unknown")
            self.sensor_status[sensor_id] = status
            if status != old_status:
                logger.info(f"STATUS CHANGE: {sensor_id} is now {status}")
        except Exception as e:
            logger.error(f"Error handling status: {e}")
    
    def handle_alert(self, topic: str, payload: bytes):
        """
        Observe alerts generated by autonomous sensors (emergent behavior).
        
        These alerts are the result of DISTRIBUTED consensus, not central control!
        
        Args:
            topic: MQTT Topic (e.g., weather/alert/pyrenees/meteo/meteo-001)
            payload: Alert information
        """
        try:
            data = json.loads(payload.decode('utf-8'))
            sensor_id = data.get("sensor_id")
            risk_level = data.get("risk_level", 0.0)
            message = data.get("message", "")
            
            # Store alert
            alert_record = {
                "sensor_id": sensor_id,
                "timestamp": datetime.now().isoformat(),
                "risk_level": risk_level,
                "message": message,
                "data": data
            }
            self.alerts.append(alert_record)
            self.message_count["alert"] += 1
            
            # Log with high visibility
            logger.warning(f"ALERT from {sensor_id}: {message} (Risk: {risk_level:.2f})")
            logger.warning(f"This alert was generated by DISTRIBUTED CONSENSUS among sensors")
            
            # Optional: Provide feedback for learning
            # (In a real system, you might analyze if the alert was correct)
            # self._send_feedback(sensor_id, "correct")  # or "false_alarm"
        
        except Exception as e:
            logger.error(f"Error handling alert: {e}")
    
    def handle_belief(self, topic: str, payload: bytes):
        """
        Observe beliefs (opinions) published by sensors.
        
        This is the KEY of DAI: each sensor shares its interpretation,
        not just raw data. This allows emergent collective intelligence.
        
        Args:
            topic: MQTT Topic (e.g., weather/belief/pyrenees/meteo/meteo-001)
            payload: Belief information
        """
        try:
            belief = json.loads(payload.decode('utf-8'))
            sensor_id = belief.get("sensor_id")
            local_risk = belief.get("local_risk", 0.0)
            risk_level = belief.get("risk_level", "unknown")
            neighbor_count = belief.get("neighbor_count", 0)
            neighbor_avg = belief.get("neighbor_avg_risk")
            would_alert = belief.get("would_alert", False)
            
            # Store belief
            self.sensor_beliefs[sensor_id] = {
                "local_risk": local_risk,
                "risk_level": risk_level,
                "neighbor_count": neighbor_count,
                "neighbor_avg_risk": neighbor_avg,
                "would_alert": would_alert,
                "timestamp": datetime.now().isoformat()
            }
            
            self.message_count["belief"] += 1
            
            # Log belief with context
            consensus_str = f"(neighbors avg: {neighbor_avg:.2f})" if neighbor_avg else "(no neighbors)"
            alert_str = "WOULD ALERT" if would_alert else "quiet"
            
            logger.info(f"BELIEF [{sensor_id}]: Risk={local_risk:.2f} ({risk_level}) "
                       f"{consensus_str} {alert_str}")
        
        except Exception as e:
            logger.error(f"Error handling belief: {e}")
    
    def _assign_sector(self, sensor_id: str) -> str:
        """
        Asigna automÃ¡ticamente un sector disponible al sensor.
        
        Args:
            sensor_id: ID del sensor
            
        Returns:
            Sector asignado o None si no hay disponibles
        """
        for sector in self.available_sectors:
            if sector not in self.assigned_sectors:
                self.assigned_sectors[sector] = sensor_id
                return sector
        return None
    
    def _send_sector_assignment(self, sensor_id: str, sector: str):
        """
        EnvÃ­a asignaciÃ³n de sector al sensor.
        
        Args:
            sensor_id: ID del sensor
            sector: Sector asignado
        """
        assignment_payload = {
            "action": "ASSIGN_SECTOR",
            "sector": sector,
            "timestamp": int(time.time())
        }
        
        topic = assign_sector_topic(sensor_id)
        self.client.publish(topic, json.dumps(assignment_payload), qos=2)
        logger.info(f"Assigned sector {sector} to {sensor_id}")
    
    def _reject_sensor(self, sensor_id: str, reason: str = None):
        """
        Rechaza un sensor y le ordena apagarse.
        
        Args:
            sensor_id: ID del sensor a rechazar
            reason: RazÃ³n del rechazo
        """
        if reason is None:
            reason = f"Maximum sensors ({self.max_sensors}) already connected"
        
        reject_payload = {
            "action": "SHUTDOWN",
            "reason": reason,
            "timestamp": int(time.time()),
            "retry_after": 60
        }
        
        topic = reject_topic(sensor_id)
        self.client.publish(topic, json.dumps(reject_payload), qos=2)
        logger.warning(f"Sent SHUTDOWN command to {sensor_id}")
    
    def _shutdown_all_sensors(self):
        """
        Send shutdown command to all connected sensors.
        """
        for sensor_id in list(self.connected_sensors):
            shutdown_payload = {
                "action": "SHUTDOWN",
                "reason": "Monitor shutting down",
                "timestamp": int(time.time()),
                "retry_after": 0
            }
            topic = reject_topic(sensor_id)
            self.client.publish(topic, json.dumps(shutdown_payload), qos=2)
            logger.info(f"Sent shutdown to {sensor_id}")
    
    def _send_feedback(self, sensor_id: str, site: str, sensor_type: str, feedback_type: str):
        """
        Send feedback to a sensor for learning (optional feature).
        
        Args:
            sensor_id: Target sensor ID
            site: Sensor site
            sensor_type: Sensor type
            feedback_type: 'false_alarm', 'missed_event', or 'correct'
        """
        feedback_payload = {
            "type": feedback_type,
            "timestamp": int(time.time()),
            "from": "monitor"
        }
        
        topic = feedback_topic(site, sensor_type, sensor_id)
        self.client.publish(topic, json.dumps(feedback_payload), qos=1)
        logger.info(f"Feedback sent to {sensor_id}: {feedback_type}")
    
    def get_statistics(self) -> dict:
        """
        Get comprehensive statistics about the DAI system.
        
        Returns:
            Dictionary with system statistics
        """
        uptime = time.time() - self.start_time
        
        # Calculate risk distribution
        risk_levels = {"stable": 0, "moderate": 0, "high": 0, "critical": 0}
        for belief in self.sensor_beliefs.values():
            level = belief.get("risk_level", "unknown")
            if level in risk_levels:
                risk_levels[level] += 1
        
        # Count sensors that would alert
        would_alert_count = sum(1 for b in self.sensor_beliefs.values() if b.get("would_alert", False))
        
        # Get sector distribution
        sectors = list(self.sensor_sectors.values())
        
        stats = {
            "uptime_seconds": round(uptime, 1),
            "connected_sensors": len(self.connected_sensors),
            "max_sensors": self.max_sensors,
            "available_slots": self.max_sensors - len(self.connected_sensors),
            "sensor_list": sorted(list(self.connected_sensors)),
            "sectors": sorted(sectors),
            "total_sensors_seen": len(self.sensor_data),
            "online_sensors": sum(1 for s in self.sensor_status.values() if s == "online"),
            "offline_sensors": sum(1 for s in self.sensor_status.values() if s == "offline"),
            "messages_received": self.message_count,
            "total_alerts": len(self.alerts),
            "sensors_would_alert": would_alert_count,
            "risk_distribution": risk_levels,
            "active_beliefs": len(self.sensor_beliefs)
        }
        
        return stats
    
    def print_system_summary(self):
        """Print a human-readable summary of the DAI system state."""
        stats = self.get_statistics()
        
        print("\n" + "="*80)
        print("DAI WEATHER SYSTEM - Status Summary")
        print("="*80)
        print(f"Uptime: {stats['uptime_seconds']:.1f}s")
        print(f"\nSENSOR MANAGEMENT:")
        print(f"   Connected: {stats['connected_sensors']}/{stats['max_sensors']} (Available slots: {stats['available_slots']})")
        if stats['sensor_list']:
            print(f"   Active sensors: {', '.join(stats['sensor_list'])}")
            print(f"   Sectors: {', '.join(stats['sectors'])}")
        else:
            print(f"   No sensors connected yet")
        print(f"\nMESSAGES:")
        print(f"   Data: {stats['messages_received']['data']}")
        print(f"   Beliefs: {stats['messages_received']['belief']}")
        print(f"   Alerts: {stats['messages_received']['alert']}")
        print(f"   Status: {stats['messages_received']['status']}")
        print(f"\nALERTS & RISKS:")
        print(f"   Total Alerts: {stats['total_alerts']}")
        print(f"   Sensors ready to alert: {stats['sensors_would_alert']}")
        print(f"   Risk Distribution:")
        for level, count in stats['risk_distribution'].items():
            symbol = {"stable": "[OK]", "moderate": "[!]", "high": "[!!]", "critical": "[!!!]"}.get(level, "[?]")
            print(f"      {symbol} {level:>10}: {count} sensors")
        print("="*80)
        print("Distributed Intelligence: Sensors make autonomous decisions")
        print("Monitor Role: Observer, Logger, and Connection Manager")
        print("="*80 + "\n")
    
    def _stats_display_loop(self):
        """Background thread to display statistics periodically"""
        while self.running:
            time.sleep(self.stats_interval)
            if self.running:
                self.print_system_summary()
    
    def _command_loop(self):
        """Background thread to handle user commands"""
        logger.info("\nðŸŽ® Commands available: 'status' | 'quit'")
        while self.running:
            try:
                cmd = input("> ").strip().lower()
                
                if cmd == "status":
                    self.print_system_summary()
                elif cmd == "quit":
                    logger.info("\nShutting down monitor...")
                    logger.info("Sending shutdown command to all connected sensors...")
                    self._shutdown_all_sensors()
                    time.sleep(1)  # Give sensors time to receive shutdown
                    self.running = False
                    self.client.disconnect()
                    break
                elif cmd:
                    logger.warning(f"Unknown command: '{cmd}'. Use 'status' or 'quit'")
            except EOFError:
                break
            except KeyboardInterrupt:
                break
    
    def start(self):
        """Start the monitor"""
        try:
            logger.info(f"Connecting to {self.broker}:{self.port}")
            self.client.connect(self.broker, self.port, keepalive=60)
            
            self.running = True
            
            # Start MQTT loop in background
            self.client.loop_start()
            
            # Start stats display thread
            if self.stats_interval > 0:
                stats_thread = threading.Thread(target=self._stats_display_loop, daemon=True)
                stats_thread.start()
                logger.info(f"Statistics will be displayed every {self.stats_interval}s")

            logger.info("\nMonitor running. Waiting for sensor connections...\n")
            
            # Run command loop in main thread
            self._command_loop()
            
        except KeyboardInterrupt:
            logger.info("\nStopping monitor...")
            self.stop()
        except Exception as e:
            logger.error(f"Error in the monitor: {e}")
            raise
    
    def stop(self):
        """Stop the monitor and show final statistics."""
        logger.info("\nStopping DAI Monitor...")
        
        self.running = False
        
        # Show final summary
        self.print_system_summary()
        
        # Save stats to log
        stats = self.get_statistics()
        if self.verbose:
            logger.info(f"Final statistics: {json.dumps(stats, indent=2)}")
        
        self.client.disconnect()
        logger.info("Monitor stopped gracefully")


def parse_arguments():
    """Parse command-line arguments"""
    parser = argparse.ArgumentParser(
        description="DAI Weather Monitor - Observes and manages sensor network",
        formatter_class=argparse.RawDescriptionHelpFormatter
    )
    
    parser.add_argument(
        "-b", "--broker",
        type=str,
        default="localhost",
        help="MQTT broker address (default: localhost)"
    )
    
    parser.add_argument(
        "-p", "--port",
        type=int,
        default=1883,
        help="MQTT broker port (default: 1883)"
    )
    
    parser.add_argument(
        "-s", "--stats-interval",
        type=int,
        default=30,
        help="Statistics display interval in seconds (default: 30, 0=disable)"
    )
    
    parser.add_argument(
        "-v", "--verbose",
        action="store_true",
        help="Enable verbose logging"
    )
    
    return parser.parse_args()


def main():
    """Main function to run the monitor"""
    args = parse_arguments()
    
    if args.verbose:
        logging.getLogger().setLevel(logging.DEBUG)
    
    monitor = WeatherMonitor(
        broker=args.broker,
        port=args.port,
        stats_interval=args.stats_interval,
        verbose=args.verbose
    )
    
    monitor.start()


if __name__ == "__main__":
    main()
